// Copyright 2014 Codehack.com All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package limits

import (
	"crypto/md5"
	"encoding/hex"
	"github.com/codehack/go-relax"
	"log"
	"net/http"
	"runtime"
	"strconv"
	"time"
)

// Quota allows request limiting capabilities to the service, resource
// or a specific route. It uses interchangeable Container objects to implement
// the token-bucket (TB) algorithm. TB allows for limiting requests and
// burstiness of those.
//
// TB works by setting a maximum number of tokens, or Capacity, that a
// resource can give to each request per client. If a client has taken,
// or consumed, all it's capacity of tokens it is denied access - with HTTP
// status code 429 ("Too Many Requests"). Further requests from the same
// client will be denied until after its capacity is renewed. This is done
// by adding a number of tokens per minute, or the Fillrate.
//
// See also, https://en.wikipedia.org/wiki/Token_bucket
type Filter struct {
	// Memory sets limits on application and system memory usage. The memory
	// stats are updated every minute and compared. If any limit is reached,
	// a response is sent with HTTP status 503-"Service Unavailable".
	// See also, runtime.MemStats
	Memory struct {
		// Check if false, then this check is not done.
		// Defaults to false.
		Check bool

		// Allow sets a limit on current used memory size, in bytes. This value
		// ideally should be a number multiple of 2.
		// Defaults to 0 (disabled)
		// 	Alloc: 5242880 // 5MB
		Alloc uint64

		// Sys sets a limit on system memory usage size, in bytes. This value
		// ideally should be a number multiple of 2.
		// Defaults to 1e9 (1000000000 bytes)
		Sys uint64
	}

	Throttle struct {
		// Check if false, then this check is not done.
		// Defaults to false.
		Check    bool
		Requests int
		Per      time.Duration
	}

	// Usage defines request usage limits by implementing the token bucket algorithm.
	// See: https://en.wikipedia.org/wiki/Token_bucket
	//
	// Each client is assigned a (semi) unique key and given a bucket of tokens
	// to spend per request. If a client consumes all his tokens, a response is
	// sent with HTTP status 429-"Too Many Requests". At this time the client won't
	// be allowed any more requests until a renewal period has passed. Repeated
	// attempts while the timeout is in effect will simply reset the timer,
	// prolonging the wait and dropping the requests.
	Usage struct {
		// Check if false, then this check is not done.
		// Defaults to false.
		Check bool

		// Container is an interface implemented by the bucket device.
		// Defaults to a MemBucket container, with settings:
		// 		maxEntries = 1000 // number of keys to monitor.
		// 		capacity   = 100  // total tokens per key.
		// 		fillrate   = 1    // tokens renewed per minute per key.
		// MemBucket is a memory-based container using keys in an LRU cache.
		Container

		// Ration is the number of tokens to consume per request.
		// Defaults to 1.
		Ration int

		// Keygen is a function used to generate semi-unique ID's for each client.
		// The default function, MD5RequestKey, uses an MD5 hash on client address
		// and user agent, or the username of an authenticated client.
		Keygen func(relax.Context) string
	}
}

// Run processes the filter. No info is passed.
// tooManyRequests responds with HTTP status 429-"Too Many Requests".
// A plain error is used in case of abuse.
// See https://tools.ietf.org/html/rfc6585#section-4
func (f *Filter) Run(next relax.HandlerFunc) relax.HandlerFunc {
	log.Printf("%#v", f)
	if f.Memory.Sys == 0 {
		f.Memory.Sys = 1e9 // 1GB system memory
	}
	if f.Usage.Container == nil {
		f.Usage.Container = NewMemBucket(1000, 100, 1)
	}
	if f.Usage.Keygen == nil {
		f.Usage.Keygen = MD5RequestKey
	}
	if f.Usage.Ration == 0 {
		f.Usage.Ration = 1
	}

	// Nothing is enabled, turn on usage check.
	if !f.Memory.Check && !f.Throttle.Check && !f.Usage.Check {
		f.Usage.Check = true
	}

	return func(ctx *relax.Context) {
		// Check memory limit
		if f.Memory.Check {
			if f.Memory.Alloc != 0 && f.Memory.Alloc < m0.Alloc {
				http.Error(ctx, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)
				return
			}
			if f.Memory.Sys != 0 && f.Memory.Sys < m0.Sys {
				http.Error(ctx, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)
				return
			}
		}

		// Throttle requests.
		if f.Throttle.Requests != 0 {

		}

		// Usage limits
		if f.Usage.Check {
			key := f.Usage.Keygen(*ctx)
			// println("KEY", key)
			tokens, when, ok := f.Usage.Consume(key, f.Usage.Ration)
			if !ok {
				ctx.Header().Set("Retry-After", strconv.Itoa(when))
				http.Error(ctx, http.StatusText(relax.StatusTooManyRequests), relax.StatusTooManyRequests)
				return
			}
			ctx.Header().Set("RateLimit-Limit", strconv.Itoa(f.Usage.Capacity()))
			ctx.Header().Set("RateLimit-Remaining", strconv.Itoa(tokens))
			ctx.Header().Set("RateLimit-Reset", strconv.Itoa(when))
		}

		next(ctx)
	}
}

// MD5RequestKey returns a key made from MD5 hash of Request.RemoteAddr and
// Request.UserAgent. But if the client has been authenticated, it will
// use the username as key.
func MD5RequestKey(c relax.Context) string {
	if c.Info.Contains("auth.user") {
		return "quota:" + c.Info.Get("auth.user")
	}
	h := md5.New()
	host, _ := SplitPort(c.Request.RemoteAddr)
	h.Write([]byte(host))
	h.Write([]byte(c.Request.UserAgent()))
	return "quota:" + hex.EncodeToString(h.Sum(nil))
}

// SplitPort splits an host:port address and returns the parts.
func SplitPort(addr string) (string, string) {
	for i := len(addr) - 1; i >= 0; i-- {
		if addr[i] == ':' {
			return addr[:i], addr[i+1:]
		}
	}
	return addr, ""
}
